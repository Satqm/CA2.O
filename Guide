I'll guide you through the changes step by step. These changes will:

1. Collect user's name during license activation (instead of hardcoding "Satyam Kumar")
2. Improve the subject hours calculation logic to respect manual inputs

ðŸ“¦ CHANGES NEEDED

PART 1: Collect User Name During License Activation

Step 1: Add Name Input Field in Welcome Screen

Find this code in the HTML (around line 300-320):

```html
<div class="license-input-group">
    <input type="text" 
           id="license-input" 
           class="license-input" 
           placeholder="Enter your license key"
           maxlength="64">
    <button class="license-activate-btn" id="license-activate-btn">
        <i class="fas fa-check"></i> Activate
    </button>
</div>
```

REPLACE IT WITH:

```html
<div class="license-input-group">
    <input type="text" 
           id="user-name-input" 
           class="license-input" 
           placeholder="Enter your name"
           maxlength="50">
    <input type="text" 
           id="license-input" 
           class="license-input" 
           placeholder="Enter your license key"
           maxlength="64">
    <button class="license-activate-btn" id="license-activate-btn">
        <i class="fas fa-check"></i> Activate
    </button>
</div>
```

Step 2: Update License Details Section

Find this code (around line 450-470):

```html
<div class="license-detail-item">
    <i class="fas fa-user"></i>
    <span>Customer: <span id="license-customer">-</span></span>
</div>
```

REPLACE IT WITH:

```html
<div class="license-detail-item">
    <i class="fas fa-user"></i>
    <span>User: <span id="license-customer">-</span></span>
</div>
```

Step 3: Modify the activateLicense() function in JavaScript

Find this function in the JavaScript (around line 1500-1600):

```javascript
function activateLicense() {
    const licenseInput = document.getElementById('license-input');
    let licenseKey = licenseInput.value;
    
    if (!licenseKey) {
        showLicenseStatus('expired', 'Please enter a license key');
        return;
    }
    
    // Apply aggressive sanitization
    licenseKey = licenseKey.trim().toUpperCase().replace(/\s+/g, '');
    
    // Update input with cleaned value
    licenseInput.value = licenseKey;
    
    // Handle demo license
    if (licenseKey === DEMO_LICENSE.replace(/\s+/g, '').toUpperCase()) {
        useDemoLicense();
        return;
    }
    
    const validation = validateLicense(licenseKey);
            
    if (validation.valid) {
        currentLicense = {
            key: licenseKey,
            ...validation.data
        };
        
        DataStorage.save('license', currentLicense);
        showLicenseStatus('active', 'License activated successfully!');
        licenseInput.classList.add('valid');
        licenseInput.classList.remove('invalid');
        
        // Update UI
        document.getElementById('license-type').textContent = currentLicense.type || 'Premium';
        document.getElementById('license-customer').textContent = currentLicense.customer || 'Premium User';
        document.getElementById('license-expiry').textContent = currentLicense.expiry || 'Lifetime';
        
        enableAppAccess();
    } else {
        showLicenseStatus('expired', validation.error || 'Invalid license key');
        licenseInput.classList.add('invalid');
        licenseInput.classList.remove('valid');
    }
}
```

REPLACE IT WITH:

```javascript
function activateLicense() {
    const userNameInput = document.getElementById('user-name-input');
    const licenseInput = document.getElementById('license-input');
    let userName = userNameInput.value.trim();
    let licenseKey = licenseInput.value;
    
    if (!userName) {
        showLicenseStatus('expired', 'Please enter your name');
        userNameInput.focus();
        return;
    }
    
    if (!licenseKey) {
        showLicenseStatus('expired', 'Please enter a license key');
        licenseInput.focus();
        return;
    }
    
    // Apply aggressive sanitization
    licenseKey = licenseKey.trim().toUpperCase().replace(/\s+/g, '');
    userName = userName.substring(0, 50); // Limit to 50 chars
    
    // Update inputs with cleaned values
    userNameInput.value = userName;
    licenseInput.value = licenseKey;
    
    // Handle demo license
    if (licenseKey === DEMO_LICENSE.replace(/\s+/g, '').toUpperCase()) {
        currentUser.name = userName || 'Demo User';
        useDemoLicense();
        return;
    }
    
    const validation = validateLicense(licenseKey);
            
    if (validation.valid) {
        currentLicense = {
            key: licenseKey,
            ...validation.data
        };
        
        // Store user name
        currentUser.name = userName;
        currentUser.initials = userName.split(' ').map(n => n[0]).join('').toUpperCase().substring(0, 2);
        
        DataStorage.save('license', currentLicense);
        DataStorage.save('user', currentUser);
        
        showLicenseStatus('active', 'License activated successfully!');
        licenseInput.classList.add('valid');
        userNameInput.classList.add('valid');
        
        // Update UI
        document.getElementById('license-type').textContent = currentLicense.type || 'Premium';
        document.getElementById('license-customer').textContent = userName || 'Premium User';
        document.getElementById('license-expiry').textContent = currentLicense.expiry || 'Lifetime';
        
        // Update user UI
        updateUserUI();
        
        enableAppAccess();
    } else {
        showLicenseStatus('expired', validation.error || 'Invalid license key');
        licenseInput.classList.add('invalid');
    }
}
```

Step 4: Update the useDemoLicense() function

Find this function (around line 1600-1650):

```javascript
function useDemoLicense() {
    const trialData = DataStorage.load('trial');
    
    if (!trialData || !trialData.active) {
        // Start new trial
        const trialStart = new Date().toISOString();
        DataStorage.save('trial', {
            active: true,
            startDate: trialStart,
            type: 'demo'
        });
        
        isTrialActive = true;
        trialStartDate = trialStart;
        trialDaysLeft = 7;
        
        // Pre-fill demo license
        document.getElementById('license-input').value = DEMO_LICENSE;
        
        showLicenseStatus('trial', 'Demo license activated! 7-day trial started.');
        document.getElementById('trial-info').style.display = 'block';
        document.getElementById('trial-days').textContent = trialDaysLeft;
        document.getElementById('license-input').classList.add('valid');
        
        enableAppAccess();
    } else {
        // Trial already active
        trialDaysLeft = calculateTrialDaysLeft(trialData.startDate);
        if (trialDaysLeft > 0) {
            showLicenseStatus('trial', `Trial active - ${trialDaysLeft} days remaining`);
            document.getElementById('trial-info').style.display = 'block';
            document.getElementById('trial-days').textContent = trialDaysLeft;
            enableAppAccess();
        } else {
            showLicenseStatus('expired', 'Trial period has expired. Please activate a license.');
        }
    }
}
```

REPLACE IT WITH:

```javascript
function useDemoLicense() {
    const userNameInput = document.getElementById('user-name-input');
    let userName = userNameInput ? userNameInput.value.trim() : 'Demo User';
    
    if (!userName) {
        userName = 'Demo User';
    }
    
    // Set user name
    currentUser.name = userName;
    currentUser.initials = userName.split(' ').map(n => n[0]).join('').toUpperCase().substring(0, 2);
    DataStorage.save('user', currentUser);
    
    const trialData = DataStorage.load('trial');
    
    if (!trialData || !trialData.active) {
        // Start new trial
        const trialStart = new Date().toISOString();
        DataStorage.save('trial', {
            active: true,
            startDate: trialStart,
            type: 'demo'
        });
        
        isTrialActive = true;
        trialStartDate = trialStart;
        trialDaysLeft = 7;
        
        // Pre-fill demo license
        document.getElementById('license-input').value = DEMO_LICENSE;
        
        showLicenseStatus('trial', 'Demo license activated! 7-day trial started.');
        document.getElementById('trial-info').style.display = 'block';
        document.getElementById('trial-days').textContent = trialDaysLeft;
        document.getElementById('license-input').classList.add('valid');
        
        // Update user UI
        updateUserUI();
        
        enableAppAccess();
    } else {
        // Trial already active
        trialDaysLeft = calculateTrialDaysLeft(trialData.startDate);
        if (trialDaysLeft > 0) {
            showLicenseStatus('trial', `Trial active - ${trialDaysLeft} days remaining`);
            document.getElementById('trial-info').style.display = 'block';
            document.getElementById('trial-days').textContent = trialDaysLeft;
            
            // Update user UI
            updateUserUI();
            
            enableAppAccess();
        } else {
            showLicenseStatus('expired', 'Trial period has expired. Please activate a license.');
        }
    }
}
```

PART 2: Improve Subject Hours Logic

Step 1: Update the toggleTopicStatus() function

Find this function (around line 3200-3300):

```javascript
function toggleTopicStatus(subjectId, topicName) {
    if (!userProgress.subjects[subjectId] || !userProgress.subjects[subjectId].topics[topicName]) {
        return;
    }
    
    const topic = userProgress.subjects[subjectId].topics[topicName];
    const currentStatus = topic.status;
    
    // Cycle through statuses: not-started -> inprogress -> completed -> not-started
    const nextStatus = currentStatus === 'not-started' ? 'inprogress' : 
                     currentStatus === 'inprogress' ? 'completed' : 'not-started';
    
    topic.status = nextStatus;
    
    // If marking as completed, calculate hours based on weightage
    if (nextStatus === 'completed') {
        // Find topic data from syllabus to get weightage
        const subjectData = syllabusData[subjectId];
        const syllabusTopic = subjectData.topics.find(t => t.name === topicName);
        
        if (syllabusTopic) {
            // Calculate topic planned hours based on subject distribution
            const subjectPlannedHours = userStudyPlan?.subjectHours?.[subjectId] || 0;
            const topicWeightage = syllabusTopic.weightage;
            const topicPlannedHours = (topicWeightage / 100) * subjectPlannedHours;
            
            Object.keys(topic.subtopics).forEach(subtopicName => {
                const subtopic = topic.subtopics[subtopicName];
                
                // If user hasn't entered hours, calculate based on subtopic weightage
                if (!subtopic.actualHours || subtopic.actualHours === 0) {
                    // Find subtopic data to get its weight
                    const subtopicData = syllabusTopic.subtopics.find(s => s.name === subtopicName);
                    if (subtopicData) {
                        const subtopicWeightage = subtopicData.weight;
                        // Calculate hours: subtopic weight * topic planned hours
                        subtopic.actualHours = (subtopicWeightage / 100) * topicPlannedHours;
                    } else {
                        // Fallback: distribute equally
                        const numSubtopics = Object.keys(topic.subtopics).length;
                        subtopic.actualHours = topicPlannedHours / numSubtopics;
                    }
                }
                
                subtopic.completed = true;
            });
        } else {
            // If syllabus topic not found, just mark subtopics as completed
            Object.keys(topic.subtopics).forEach(subtopicName => {
                topic.subtopics[subtopicName].completed = true;
            });
        }
    } else if (nextStatus === 'not-started') {
        // Reset hours if going back to not-started
        Object.keys(topic.subtopics).forEach(subtopicName => {
            const subtopic = topic.subtopics[subtopicName];
            // Only reset if it's the default 1 hour (indicating it was auto-set)
            if (subtopic.actualHours === 1) {
                subtopic.actualHours = 0;
            }
            subtopic.completed = false;
        });
    }
    
    // Update completed topics count
    updateCompletedTopics(subjectId);
    
    DataStorage.save('progress', userProgress);
    loadSubjectContent();
    updateDashboard(); // Update dashboard instantly
    
    showToast(`Topic marked as ${nextStatus}`, 'success');
}
```

REPLACE IT WITH:

```javascript
function toggleTopicStatus(subjectId, topicName) {
    if (!userProgress.subjects[subjectId] || !userProgress.subjects[subjectId].topics[topicName]) {
        return;
    }
    
    const topic = userProgress.subjects[subjectId].topics[topicName];
    const currentStatus = topic.status;
    
    // Cycle through statuses: not-started -> inprogress -> completed -> not-started
    const nextStatus = currentStatus === 'not-started' ? 'inprogress' : 
                     currentStatus === 'inprogress' ? 'completed' : 'not-started';
    
    topic.status = nextStatus;
    
    // If marking as completed, respect user's manual hours input
    if (nextStatus === 'completed') {
        // Find topic data from syllabus to get weightage
        const subjectData = syllabusData[subjectId];
        const syllabusTopic = subjectData.topics.find(t => t.name === topicName);
        
        if (syllabusTopic) {
            // Calculate topic planned hours based on subject distribution
            const subjectPlannedHours = userStudyPlan?.subjectHours?.[subjectId] || 0;
            const topicWeightage = syllabusTopic.weightage;
            const topicPlannedHours = (topicWeightage / 100) * subjectPlannedHours;
            
            Object.keys(topic.subtopics).forEach(subtopicName => {
                const subtopic = topic.subtopics[subtopicName];
                
                // IMPORTANT: Only auto-calculate hours if user hasn't entered ANY hours
                // (actualHours is 0 or doesn't exist)
                if (!subtopic.actualHours || subtopic.actualHours === 0) {
                    // Find subtopic data to get its weight
                    const subtopicData = syllabusTopic.subtopics.find(s => s.name === subtopicName);
                    if (subtopicData) {
                        const subtopicWeightage = subtopicData.weight;
                        // Calculate hours: subtopic weight * topic planned hours
                        subtopic.actualHours = (subtopicWeightage / 100) * topicPlannedHours;
                    } else {
                        // Fallback: distribute equally
                        const numSubtopics = Object.keys(topic.subtopics).length;
                        subtopic.actualHours = topicPlannedHours / numSubtopics;
                    }
                    subtopic.completed = true;
                } else {
                    // User has manually entered hours - mark as completed but keep their hours
                    subtopic.completed = true;
                }
            });
        } else {
            // If syllabus topic not found, just mark subtopics as completed
            Object.keys(topic.subtopics).forEach(subtopicName => {
                topic.subtopics[subtopicName].completed = true;
            });
        }
    } else if (nextStatus === 'not-started') {
        // Reset hours if going back to not-started, but only for auto-calculated hours
        // Don't reset user's manual entries
        Object.keys(topic.subtopics).forEach(subtopicName => {
            const subtopic = topic.subtopics[subtopicName];
            
            // Check if hours were auto-calculated (close to rounded weight-based value)
            if (syllabusData[subjectId]) {
                const syllabusTopic = syllabusData[subjectId].topics.find(t => t.name === topicName);
                if (syllabusTopic) {
                    const subjectPlannedHours = userStudyPlan?.subjectHours?.[subjectId] || 0;
                    const topicWeightage = syllabusTopic.weightage;
                    const topicPlannedHours = (topicWeightage / 100) * subjectPlannedHours;
                    
                    const subtopicData = syllabusTopic.subtopics.find(s => s.name === subtopicName);
                    if (subtopicData) {
                        const expectedHours = (subtopicData.weight / 100) * topicPlannedHours;
                        // If actual hours are within 10% of expected auto-calculated hours, reset them
                        if (Math.abs(subtopic.actualHours - expectedHours) < (expectedHours * 0.1)) {
                            subtopic.actualHours = 0;
                        }
                    }
                }
            }
            
            subtopic.completed = false;
        });
    }
    
    // Update completed topics count
    updateCompletedTopics(subjectId);
    
    DataStorage.save('progress', userProgress);
    loadSubjectContent();
    updateDashboard(); // Update dashboard instantly
    
    showToast(`Topic marked as ${nextStatus}`, 'success');
}
```

Step 2: Update the saveAllProgress() function to be smarter

Find this function (around line 3350-3400):

```javascript
function saveAllProgress() {
    // Collect all time inputs
    const timeInputs = document.querySelectorAll('input[type="number"][id^="time-"]');
    let savedCount = 0;
    
    timeInputs.forEach(input => {
        const id = input.id.replace('time-', '');
        const [subjectId, topicNameEncoded, subtopicNameEncoded] = id.split('-');
        
        // Decode names (replace hyphens with spaces)
        const topicName = topicNameEncoded.replace(/-/g, ' ');
        const subtopicName = subtopicNameEncoded.replace(/-/g, ' ');
        
        const hours = parseFloat(input.value) || 0;
        
        if (hours >= 0) {
            // Ensure progress structure exists
            if (!userProgress.subjects[subjectId]) {
                userProgress.subjects[subjectId] = { topics: {}, completedTopics: 0, totalTopics: syllabusData[subjectId].topics.length };
            }
            if (!userProgress.subjects[subjectId].topics[topicName]) {
                userProgress.subjects[subjectId].topics[topicName] = { status: 'not-started', subtopics: {} };
            }
            if (!userProgress.subjects[subjectId].topics[topicName].subtopics[subtopicName]) {
                userProgress.subjects[subjectId].topics[topicName].subtopics[subtopicName] = { actualHours: 0, completed: false };
            }
            
            // Update hours
            userProgress.subjects[subjectId].topics[topicName].subtopics[subtopicName].actualHours = hours;
            
            // Auto-mark as completed if hours > 0
            userProgress.subjects[subjectId].topics[topicName].subtopics[subtopicName].completed = hours > 0;
            
            // Auto-mark topic as in-progress if hours added
            if (hours > 0 && userProgress.subjects[subjectId].topics[topicName].status === 'not-started') {
                userProgress.subjects[subjectId].topics[topicName].status = 'inprogress';
            }
            
            savedCount++;
        }
    });
    
    // Update completed topics counts
    for (const subjectId in userProgress.subjects) {
        updateCompletedTopics(subjectId);
    }
    
    // Save to storage
    DataStorage.save('progress', userProgress);
    updateDashboard();
    
    showToast(`${savedCount} subtopic hours saved successfully!`, 'success');
}
```

REPLACE IT WITH:

```javascript
function saveAllProgress() {
    // Collect all time inputs
    const timeInputs = document.querySelectorAll('input[type="number"][id^="time-"]');
    let savedCount = 0;
    let manualEntries = 0;
    
    timeInputs.forEach(input => {
        const id = input.id.replace('time-', '');
        const [subjectId, topicNameEncoded, subtopicNameEncoded] = id.split('-');
        
        // Decode names (replace hyphens with spaces)
        const topicName = topicNameEncoded.replace(/-/g, ' ');
        const subtopicName = subtopicNameEncoded.replace(/-/g, ' ');
        
        const hours = parseFloat(input.value) || 0;
        
        if (hours >= 0) {
            // Ensure progress structure exists
            if (!userProgress.subjects[subjectId]) {
                userProgress.subjects[subjectId] = { topics: {}, completedTopics: 0, totalTopics: syllabusData[subjectId].topics.length };
            }
            if (!userProgress.subjects[subjectId].topics[topicName]) {
                userProgress.subjects[subjectId].topics[topicName] = { status: 'not-started', subtopics: {} };
            }
            if (!userProgress.subjects[subjectId].topics[topicName].subtopics[subtopicName]) {
                userProgress.subjects[subjectId].topics[topicName].subtopics[subtopicName] = { 
                    actualHours: 0, 
                    completed: false,
                    manualEntry: false  // Track if this was manually entered
                };
            }
            
            // Get previous hours to detect changes
            const prevHours = userProgress.subjects[subjectId].topics[topicName].subtopics[subtopicName].actualHours || 0;
            
            // Update hours
            userProgress.subjects[subjectId].topics[topicName].subtopics[subtopicName].actualHours = hours;
            
            // Mark as manual entry if user changed from auto-calculated value
            if (hours !== prevHours) {
                userProgress.subjects[subjectId].topics[topicName].subtopics[subtopicName].manualEntry = true;
                manualEntries++;
            }
            
            // Auto-mark as completed if hours > 0
            userProgress.subjects[subjectId].topics[topicName].subtopics[subtopicName].completed = hours > 0;
            
            // Auto-mark topic as in-progress if hours added
            if (hours > 0 && userProgress.subjects[subjectId].topics[topicName].status === 'not-started') {
                userProgress.subjects[subjectId].topics[topicName].status = 'inprogress';
            }
            
            savedCount++;
        }
    });
    
    // Update completed topics counts
    for (const subjectId in userProgress.subjects) {
        updateCompletedTopics(subjectId);
    }
    
    // Save to storage
    DataStorage.save('progress', userProgress);
    updateDashboard();
    
    showToast(`${savedCount} subtopic hours saved! (${manualEntries} manual entries)`, 'success');
}
```

Step 3: Add CSS for better visual feedback

Add this CSS at the end of the style section (before the closing </style> tag):

```css
/* Manual entry indicator */
.manual-entry {
    border: 2px solid #3498db !important;
    background: rgba(52, 152, 219, 0.05) !important;
}

.manual-entry-indicator {
    font-size: 10px;
    background: #3498db;
    color: white;
    padding: 2px 6px;
    border-radius: 3px;
    margin-left: 5px;
}
```

ðŸ“‹ QUICK CHECKLIST

Copy and paste in this order:

1. HTML Changes:
   Â· Add user name input field
   Â· Update license detail text
2. JavaScript Changes:
   Â· Update activateLicense() function
   Â· Update useDemoLicense() function
   Â· Update toggleTopicStatus() function
   Â· Update saveAllProgress() function
3. CSS Changes:
   Â· Add manual entry styling

ðŸŽ¯ KEY FEATURES AFTER CHANGES:

1. User Name Collection: Users enter their name during license activation
2. Respect Manual Entries: When users manually enter hours, the system won't override them when marking topics as completed
3. Better Feedback: Shows which entries are manual vs auto-calculated
4. Personalized Experience: Uses the user's name throughout the app

ðŸ”§ TROUBLESHOOTING:

If something doesn't work:

1. Make sure you copied the exact function names
2. Check browser console for errors (F12 â†’ Console)
3. Verify the element IDs match exactly
4. Try refreshing the page after making changes

The changes ensure that when a user manually enters hours in the Subjects tab, those hours are preserved and respected, even when they mark topics as completed. The system will only auto-calculate hours for subtopics that have 0 hours entered.
